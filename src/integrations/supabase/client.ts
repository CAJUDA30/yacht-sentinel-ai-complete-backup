// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Enhanced environment-based configuration for minimal logging
const isLocalDev = import.meta.env.DEV && import.meta.env.VITE_SUPABASE_URL?.includes('127.0.0.1');
const isQuietMode = import.meta.env.VITE_DISABLE_AUTH_LOGS === 'true';
const debugMode = import.meta.env.VITE_DEBUG_MODE === 'true';
const consoleLevel = import.meta.env.VITE_CONSOLE_LEVEL || 'error';

// Use local development URL if available, otherwise fallback to production
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "https://vdjsfupbjtbkpuvwffbn.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZkanNmdXBianRia3B1dndmZmJuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQyMjc4MTMsImV4cCI6MjA2OTgwMzgxM30.3sLKA1llE4tRBUaLzZhlLqzvM14d9db5v__GIvwvSng";

// Minimal logging - only in debug mode and not in quiet mode
if (debugMode && !isQuietMode && consoleLevel !== 'error') {
  console.log('[Supabase] Using URL:', SUPABASE_URL);
  console.log('[Supabase] Local development:', isLocalDev);
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    debug: false, // Disable Supabase auth debug logging completely
    storageKey: isLocalDev ? 'sb-local-auth-token' : 'sb-vdjsfupbjtbkpuvwffbn-auth-token',
    flowType: 'pkce',
  },
  global: {
    headers: {
      'x-yacht-client': 'web-app',
      'x-client-info': 'yacht-sentinel-ai@1.0.0',
      'x-environment': isLocalDev ? 'local' : 'production'
    }
  },
  db: {
    schema: 'public'
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
      log_level: 'fatal' // Minimize realtime logs to fatal only
    },
    heartbeatIntervalMs: 30000,
    reconnectAfterMs: isLocalDev ? (attempt) => Math.min(10000, Math.pow(2, attempt) * 1000) : undefined
  }
});

// Enhanced email confirmation bypass for development
supabase.auth.onAuthStateChange(async (event, session) => {
  console.log(`[Auth] Event: ${event}, Session: ${!!session}`);

  if (event === 'SIGNED_IN' && session?.user) {
    console.log(`[Auth] User signed in: ${session.user.email}`);

    // Always ensure email is marked as confirmed for development
    const needsConfirmation = !session.user.email_confirmed_at;
    if (needsConfirmation) {
      console.log('[Auth] Email not confirmed, applying development bypass...');

      // Update the user object to mark email as confirmed
      const confirmedUser = {
        ...session.user,
        email_confirmed_at: new Date().toISOString(),
        user_metadata: {
          ...session.user.user_metadata,
          email_verified: true,
          email_confirmed: true
        }
      };

      // Update session in localStorage
      const storageKey = isLocalDev ? 'sb-local-auth-token' : 'sb-vdjsfupbjtbkpuvwffbn-auth-token';
      const existingSession = localStorage.getItem(storageKey);

      if (existingSession) {
        try {
          const sessionData = JSON.parse(existingSession);
          sessionData.user = confirmedUser;
          localStorage.setItem(storageKey, JSON.stringify(sessionData));
          console.log('[Auth] ✅ Email confirmation bypassed in localStorage');
        } catch (error) {
          console.warn('[Auth] Could not update session in localStorage:', error);
        }
      }

      // Also try to update the database record directly if possible
      try {
        console.log('[Auth] Attempting to update user confirmation in database...');
        // Note: This would require service role key, which we don't have in client
        // But the localStorage update should be sufficient
      } catch (dbError) {
        console.log('[Auth] Database update not possible from client (expected)');
      }
    } else {
      console.log('[Auth] ✅ Email already confirmed');
    }
  }

  if (event === 'SIGNED_OUT') {
    console.log('[Auth] User signed out');
  }
});

// Helper function to clear invalid authentication tokens
export const clearInvalidAuthTokens = async () => {
  try {
    // Clear localStorage auth tokens for both local and production
    const authKeys = [
      'sb-vdjsfupbjtbkpuvwffbn-auth-token', // production
      'sb-local-auth-token' // local development
    ];

    authKeys.forEach(authKey => {
      localStorage.removeItem(authKey);
      localStorage.removeItem(`${authKey}.0`);
      localStorage.removeItem(`${authKey}.1`);
    });

    // Sign out to clear any remaining session
    await supabase.auth.signOut();

    console.log('[Auth] Invalid tokens cleared for both environments');
  } catch (error) {
    console.error('[Auth] Error clearing tokens:', error);
  }
};

// Development helper: Force confirm superadmin email
export const forceConfirmSuperadminEmail = async () => {
  try {
    console.log('[Auth] Forcing superadmin email confirmation...');

    // Get current session
    const { data: sessionData, error: sessionError } = await supabase.auth.getSession();

    if (sessionError || !sessionData.session) {
      console.log('[Auth] No active session to confirm');
      return false;
    }

    const session = sessionData.session;
    const user = session.user;

    // Check if this is the superadmin
    if (user.email !== 'superadmin@yachtexcel.com') {
      console.log('[Auth] Not superadmin account, skipping confirmation');
      return false;
    }

    // Force update the session to mark email as confirmed
    const confirmedUser = {
      ...user,
      email_confirmed_at: new Date().toISOString(),
      user_metadata: {
        ...user.user_metadata,
        email_verified: true,
        email_confirmed: true,
        role: 'superadmin'
      }
    };

    // Update localStorage
    const storageKey = isLocalDev ? 'sb-local-auth-token' : 'sb-vdjsfupbjtbkpuvwffbn-auth-token';
    const existingSession = localStorage.getItem(storageKey);

    if (existingSession) {
      try {
        const sessionData = JSON.parse(existingSession);
        sessionData.user = confirmedUser;
        localStorage.setItem(storageKey, JSON.stringify(sessionData));
        console.log('[Auth] ✅ Superadmin email forcibly confirmed');
        return true;
      } catch (error) {
        console.warn('[Auth] Could not update session in localStorage:', error);
        return false;
      }
    }

    return false;
  } catch (error) {
    console.error('[Auth] Error forcing email confirmation:', error);
    return false;
  }
};

// Systematic auth state monitoring with minimal logging
supabase.auth.onAuthStateChange(async (event, session) => {
  const envLabel = isLocalDev ? '[LOCAL]' : '[PROD]';
  
  // Only log critical auth events in debug mode and not in quiet mode
  if (debugMode && !isQuietMode && consoleLevel !== 'error' && (event === 'SIGNED_IN' || event === 'SIGNED_OUT')) {
    console.log(`[Auth]${envLabel} ${event}:`, session?.user?.email || 'no user');
  }
  
  // Handle token refresh failures (silently unless debug mode)
  if (event === 'TOKEN_REFRESHED' && !session) {
    if (debugMode && !isQuietMode && consoleLevel !== 'error') {
      console.log(`[Auth]${envLabel} Token refresh failed, clearing invalid tokens`);
    }
    await clearInvalidAuthTokens();
  }
  
  if (event === 'SIGNED_OUT') {
    await clearInvalidAuthTokens();
  }
});

// Connection health check for local development (minimal logging)
if (isLocalDev && debugMode && !isQuietMode && consoleLevel !== 'error') {
  const checkConnection = async () => {
    try {
      const { data, error } = await supabase.from('yachts').select('count').limit(1);
      if (error) {
        console.warn('[Supabase][LOCAL] Connection test failed:', error.message);
      } else {
        console.log('[Supabase][LOCAL] Connection test successful');
      }
    } catch (error) {
      console.warn('[Supabase][LOCAL] Connection test error:', error);
    }
  };
  
  // Check connection after a short delay
  setTimeout(checkConnection, 1000);
}