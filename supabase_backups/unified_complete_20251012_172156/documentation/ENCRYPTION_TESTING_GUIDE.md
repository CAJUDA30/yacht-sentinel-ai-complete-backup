# üß™ API Key Encryption - Testing & Verification Guide

## Quick Test Checklist

Use this guide to verify that automatic API key encryption is working correctly across your application.

---

## 1Ô∏è‚É£ Database Level Testing

### Test 1: Verify Encryption Functions Exist
```sql
-- Check if encryption functions are installed
SELECT routine_name, routine_type 
FROM information_schema.routines 
WHERE routine_name IN ('encrypt_api_key', 'decrypt_api_key', 'is_encrypted')
AND routine_schema = 'public';

-- Expected: 3 rows returned
-- ‚úÖ encrypt_api_key | FUNCTION
-- ‚úÖ decrypt_api_key | FUNCTION  
-- ‚úÖ is_encrypted    | FUNCTION
```

### Test 2: Verify Views Exist
```sql
-- Check if decryption views are created
SELECT table_name, table_type 
FROM information_schema.tables 
WHERE table_name IN ('ai_providers_with_keys', 'document_ai_processors_with_credentials')
AND table_schema = 'public';

-- Expected: 2 rows returned
-- ‚úÖ ai_providers_with_keys                        | VIEW
-- ‚úÖ document_ai_processors_with_credentials       | VIEW
```

### Test 3: Verify Triggers Exist
```sql
-- Check if auto-encryption triggers are installed
SELECT trigger_name, event_object_table, action_timing, event_manipulation
FROM information_schema.triggers
WHERE trigger_name IN ('encrypt_ai_provider_keys_trigger', 'encrypt_processor_credentials_trigger');

-- Expected: 2 rows returned
-- ‚úÖ encrypt_ai_provider_keys_trigger      | ai_providers_unified     | BEFORE | INSERT
-- ‚úÖ encrypt_ai_provider_keys_trigger      | ai_providers_unified     | BEFORE | UPDATE
-- ‚úÖ encrypt_processor_credentials_trigger | document_ai_processors   | BEFORE | INSERT
-- ‚úÖ encrypt_processor_credentials_trigger | document_ai_processors   | BEFORE | UPDATE
```

---

## 2Ô∏è‚É£ Encryption Testing

### Test 4: Insert Plain Text API Key
```sql
-- Insert a test provider with plain text API key
INSERT INTO ai_providers_unified (
  name, 
  provider_type, 
  api_key_encrypted,
  base_url,
  is_active
) VALUES (
  'Test Encryption Provider',
  'openai',
  'sk-test-plain-text-key-1234567890',  -- Plain text input
  'https://api.openai.com/v1',
  true
);

-- Verify it's encrypted in the database
SELECT 
  name,
  api_key_encrypted,
  is_encrypted(api_key_encrypted) as is_encrypted_check,
  length(api_key_encrypted) as encrypted_length
FROM ai_providers_unified
WHERE name = 'Test Encryption Provider';

-- Expected Output:
-- name                        | api_key_encrypted | is_encrypted_check | encrypted_length
-- Test Encryption Provider    | [base64 string]   | true               | 44+
-- 
-- ‚úÖ api_key_encrypted should be base64 encoded (not plain text)
-- ‚úÖ is_encrypted_check should be TRUE
-- ‚úÖ encrypted_length should be > 40 characters
```

### Test 5: Read Decrypted API Key from View
```sql
-- Read from the decryption view
SELECT 
  name,
  api_key,                    -- Decrypted plain text
  api_key_encrypted,          -- Encrypted version
  is_encrypted(api_key_encrypted) as is_stored_encrypted
FROM ai_providers_with_keys
WHERE name = 'Test Encryption Provider';

-- Expected Output:
-- name                        | api_key                              | api_key_encrypted | is_stored_encrypted
-- Test Encryption Provider    | sk-test-plain-text-key-1234567890    | [base64 string]   | true
--
-- ‚úÖ api_key should show the ORIGINAL plain text
-- ‚úÖ api_key_encrypted should show encrypted base64
-- ‚úÖ is_stored_encrypted should be TRUE
```

### Test 6: Update API Key (Re-encryption)
```sql
-- Update with a new plain text API key
UPDATE ai_providers_unified
SET api_key_encrypted = 'sk-new-updated-key-9876543210'  -- Plain text input
WHERE name = 'Test Encryption Provider';

-- Verify the new key is encrypted
SELECT 
  name,
  api_key_encrypted,
  is_encrypted(api_key_encrypted) as is_encrypted,
  substring(api_key_encrypted, 1, 10) as encrypted_preview
FROM ai_providers_unified
WHERE name = 'Test Encryption Provider';

-- Expected:
-- ‚úÖ api_key_encrypted should be DIFFERENT from previous (re-encrypted)
-- ‚úÖ is_encrypted should be TRUE
-- ‚úÖ encrypted_preview should NOT start with 'sk-'
```

### Test 7: Read Updated Key from View
```sql
-- Verify decryption of updated key
SELECT api_key
FROM ai_providers_with_keys
WHERE name = 'Test Encryption Provider';

-- Expected Output:
-- api_key
-- sk-new-updated-key-9876543210
--
-- ‚úÖ Should show the NEW plain text key (not the old one)
```

---

## 3Ô∏è‚É£ Application Level Testing

### Test 8: Read API Keys in TypeScript/React
```typescript
// In any React component or hook
import { supabase } from '@/integrations/supabase/client';

// Test reading from view
const testDecryption = async () => {
  const { data, error } = await supabase
    .from('ai_providers_with_keys')  // ‚Üê Using view
    .select('name, api_key, api_key_encrypted')
    .eq('name', 'Test Encryption Provider')
    .single();
  
  if (error) {
    console.error('‚ùå Error:', error);
    return;
  }
  
  console.log('‚úÖ Provider Name:', data.name);
  console.log('‚úÖ Decrypted API Key:', data.api_key);
  console.log('‚úÖ Encrypted Storage:', data.api_key_encrypted);
  
  // Verify decryption worked
  if (data.api_key === 'sk-new-updated-key-9876543210') {
    console.log('‚úÖ DECRYPTION SUCCESSFUL!');
  } else {
    console.log('‚ùå DECRYPTION FAILED!');
  }
};

// Run the test
testDecryption();

// Expected Console Output:
// ‚úÖ Provider Name: Test Encryption Provider
// ‚úÖ Decrypted API Key: sk-new-updated-key-9876543210
// ‚úÖ Encrypted Storage: [base64 string]
// ‚úÖ DECRYPTION SUCCESSFUL!
```

### Test 9: Write API Keys in TypeScript/React
```typescript
// Test writing (auto-encryption)
const testEncryption = async () => {
  const { data, error } = await supabase
    .from('ai_providers_unified')  // ‚Üê Using base table
    .insert({
      name: 'Auto-Encrypt Test Provider',
      provider_type: 'anthropic',
      api_key_encrypted: 'claude-api-key-plain-text-12345',  // Plain text
      base_url: 'https://api.anthropic.com/v1',
      is_active: true
    })
    .select();
  
  if (error) {
    console.error('‚ùå Insert Error:', error);
    return;
  }
  
  console.log('‚úÖ Provider Created:', data[0].name);
  console.log('‚úÖ Stored Value:', data[0].api_key_encrypted);
  
  // Now read it back from view to verify encryption happened
  const { data: readData } = await supabase
    .from('ai_providers_with_keys')
    .select('api_key, api_key_encrypted')
    .eq('name', 'Auto-Encrypt Test Provider')
    .single();
  
  console.log('‚úÖ Read Back - Plain:', readData?.api_key);
  console.log('‚úÖ Read Back - Encrypted:', readData?.api_key_encrypted);
  
  if (readData?.api_key === 'claude-api-key-plain-text-12345') {
    console.log('‚úÖ ENCRYPTION + DECRYPTION SUCCESSFUL!');
  }
};

// Run the test
testEncryption();

// Expected Console Output:
// ‚úÖ Provider Created: Auto-Encrypt Test Provider
// ‚úÖ Stored Value: [base64 encrypted string]
// ‚úÖ Read Back - Plain: claude-api-key-plain-text-12345
// ‚úÖ Read Back - Encrypted: [base64 encrypted string]
// ‚úÖ ENCRYPTION + DECRYPTION SUCCESSFUL!
```

### Test 10: Verify useAIProviderManagement Hook
```typescript
// In a React component
import { useAIProviderManagement } from '@/hooks/useAIProviderManagement';

function TestEncryptionComponent() {
  const { providers, createProvider } = useAIProviderManagement();
  
  useEffect(() => {
    if (providers.data) {
      console.log('‚úÖ Providers loaded via hook:', providers.data.length);
      
      // Check if API keys are plain text (decrypted)
      const testProvider = providers.data.find(p => 
        p.name === 'Test Encryption Provider'
      );
      
      if (testProvider) {
        console.log('‚úÖ Provider found:', testProvider.name);
        console.log('‚úÖ API Key (should be plain text):', testProvider.api_key);
        
        // Verify it's the decrypted value
        if (testProvider.api_key?.startsWith('sk-')) {
          console.log('‚úÖ API KEY SUCCESSFULLY DECRYPTED!');
        } else {
          console.log('‚ùå API KEY NOT DECRYPTED!');
        }
      }
    }
  }, [providers.data]);
  
  const handleCreateProvider = async () => {
    await createProvider.mutateAsync({
      name: 'Hook Test Provider',
      provider_type: 'xai',
      base_url: 'https://api.x.ai/v1',
      api_key_encrypted: 'xai-plain-text-key-67890',  // Plain text
      is_active: true
    } as any);
    
    console.log('‚úÖ Provider created via hook');
  };
  
  return (
    <button onClick={handleCreateProvider}>
      Test Create Provider
    </button>
  );
}

// Expected Behavior:
// 1. ‚úÖ Hook reads from 'ai_providers_with_keys' view
// 2. ‚úÖ API keys are plain text (decrypted)
// 3. ‚úÖ Create mutation uses base table (auto-encrypts)
// 4. ‚úÖ After creation, new provider's key is also decrypted when read
```

---

## 4Ô∏è‚É£ Document AI Testing

### Test 11: Document AI Processor Encryption
```sql
-- Insert a test processor with GCP credentials
INSERT INTO document_ai_processors (
  name,
  display_name,
  processor_id,
  location,
  project_id,
  gcp_credentials_encrypted,  -- Plain text JSON
  is_active
) VALUES (
  'test_processor',
  'Test Document Processor',
  'test-processor-id-123',
  'us',
  '338523806048',
  '{"type":"service_account","project_id":"yacht-sentinel","private_key":"-----BEGIN PRIVATE KEY-----\nTEST\n-----END PRIVATE KEY-----"}',
  true
);

-- Verify encryption
SELECT 
  name,
  gcp_credentials_encrypted,
  is_encrypted(gcp_credentials_encrypted) as is_encrypted
FROM document_ai_processors
WHERE name = 'test_processor';

-- Expected:
-- ‚úÖ gcp_credentials_encrypted should be base64 (not JSON)
-- ‚úÖ is_encrypted should be TRUE
```

### Test 12: Document AI Decryption View
```sql
-- Read from decryption view
SELECT 
  name,
  gcp_credentials,           -- Decrypted JSON
  gcp_credentials_encrypted  -- Encrypted base64
FROM document_ai_processors_with_credentials
WHERE name = 'test_processor';

-- Expected:
-- ‚úÖ gcp_credentials should be the ORIGINAL JSON (plain text)
-- ‚úÖ gcp_credentials_encrypted should be base64 encrypted
```

### Test 13: Document AI Component Test
```typescript
// In React component
const testDocumentAI = async () => {
  const { data } = await supabase
    .from('document_ai_processors_with_credentials')  // ‚Üê View
    .select('*')
    .eq('name', 'test_processor')
    .single();
  
  console.log('‚úÖ Processor:', data?.name);
  console.log('‚úÖ Credentials (decrypted):', data?.gcp_credentials);
  
  // Parse the JSON credentials
  const creds = typeof data?.gcp_credentials === 'string' 
    ? JSON.parse(data.gcp_credentials) 
    : data?.gcp_credentials;
  
  if (creds?.type === 'service_account') {
    console.log('‚úÖ DOCUMENT AI DECRYPTION SUCCESSFUL!');
  }
};

// Expected:
// ‚úÖ Processor: test_processor
// ‚úÖ Credentials (decrypted): {"type":"service_account",...}
// ‚úÖ DOCUMENT AI DECRYPTION SUCCESSFUL!
```

---

## 5Ô∏è‚É£ Backward Compatibility Testing

### Test 14: Plain Text Keys Still Work
```sql
-- Insert with PLAIN: prefix (bypass encryption for testing)
INSERT INTO ai_providers_unified (
  name,
  provider_type,
  api_key_encrypted,
  base_url,
  is_active
) VALUES (
  'Legacy Provider',
  'openai',
  'PLAIN:sk-legacy-unencrypted-key',  -- Won't be encrypted
  'https://api.openai.com/v1',
  true
);

-- Verify it's NOT encrypted
SELECT 
  name,
  api_key_encrypted,
  is_encrypted(api_key_encrypted) as is_encrypted
FROM ai_providers_unified
WHERE name = 'Legacy Provider';

-- Expected:
-- ‚úÖ api_key_encrypted should be 'sk-legacy-unencrypted-key' (no PLAIN: prefix)
-- ‚úÖ is_encrypted should be FALSE
```

### Test 15: Read Plain Text from View
```sql
-- Read legacy plain text key from view
SELECT api_key
FROM ai_providers_with_keys
WHERE name = 'Legacy Provider';

-- Expected:
-- api_key
-- sk-legacy-unencrypted-key
--
-- ‚úÖ Should work with plain text keys too
```

---

## 6Ô∏è‚É£ Cleanup Test Data

### Clean Up All Test Records
```sql
-- Remove all test providers
DELETE FROM ai_providers_unified 
WHERE name IN (
  'Test Encryption Provider',
  'Auto-Encrypt Test Provider',
  'Hook Test Provider',
  'Legacy Provider'
);

-- Remove test processor
DELETE FROM document_ai_processors
WHERE name = 'test_processor';

-- Verify cleanup
SELECT COUNT(*) as remaining_test_records
FROM ai_providers_unified
WHERE name LIKE '%Test%';

-- Expected: 0
```

---

## 7Ô∏è‚É£ Production Verification

### Final Production Checks

#### ‚úÖ Check 1: All Production Providers Are Encrypted
```sql
SELECT 
  COUNT(*) as total_providers,
  COUNT(*) FILTER (WHERE is_encrypted(api_key_encrypted)) as encrypted_count,
  COUNT(*) FILTER (WHERE NOT is_encrypted(api_key_encrypted)) as plain_text_count
FROM ai_providers_unified
WHERE api_key_encrypted IS NOT NULL;

-- Expected:
-- total_providers | encrypted_count | plain_text_count
-- 5               | 5               | 0
--
-- ‚úÖ encrypted_count should equal total_providers
-- ‚úÖ plain_text_count should be 0
```

#### ‚úÖ Check 2: All Views Are Accessible
```typescript
// Test all views return data
const verifyViews = async () => {
  const { data: providers } = await supabase
    .from('ai_providers_with_keys')
    .select('count')
    .single();
  
  const { data: processors } = await supabase
    .from('document_ai_processors_with_credentials')
    .select('count')
    .single();
  
  console.log('‚úÖ Providers view accessible:', !!providers);
  console.log('‚úÖ Processors view accessible:', !!processors);
};
```

#### ‚úÖ Check 3: Application Functions Normally
```typescript
// Verify normal application flow works
import { useAIProviderManagement } from '@/hooks/useAIProviderManagement';

const ProductionTest = () => {
  const { providers, testProvider } = useAIProviderManagement();
  
  const runProductionTest = async () => {
    // 1. Load providers (should use view)
    const activeProviders = providers.data?.filter(p => p.is_active);
    console.log('‚úÖ Loaded providers:', activeProviders?.length);
    
    // 2. Test a provider (should have decrypted key)
    if (activeProviders && activeProviders[0]) {
      const result = await testProvider.mutateAsync(activeProviders[0]);
      console.log('‚úÖ Provider test result:', result);
    }
    
    // 3. Verify keys are plain text
    const hasPlainTextKeys = activeProviders?.every(p => 
      p.api_key && !p.api_key.includes('base64')
    );
    console.log('‚úÖ All keys are plain text:', hasPlainTextKeys);
  };
  
  return <button onClick={runProductionTest}>Run Production Test</button>;
};
```

---

## üéØ Success Criteria

### ‚úÖ All Tests Must Pass

- [x] Encryption functions exist (Test 1)
- [x] Views exist (Test 2)
- [x] Triggers exist (Test 3)
- [x] Plain text input gets encrypted (Test 4)
- [x] Encrypted keys can be decrypted (Test 5)
- [x] Updates re-encrypt properly (Test 6, 7)
- [x] TypeScript read works (Test 8)
- [x] TypeScript write works (Test 9)
- [x] Hooks use views correctly (Test 10)
- [x] Document AI encryption works (Test 11, 12, 13)
- [x] Backward compatibility works (Test 14, 15)
- [x] Production data is encrypted (Check 1)
- [x] Views are accessible (Check 2)
- [x] Application functions normally (Check 3)

---

## üìä Testing Summary Template

```
üß™ API KEY ENCRYPTION - TEST RESULTS
====================================

Database Tests:
‚úÖ Encryption functions: [PASS/FAIL]
‚úÖ Decryption views: [PASS/FAIL]
‚úÖ Auto-encrypt triggers: [PASS/FAIL]

Encryption Tests:
‚úÖ Plain text ‚Üí encrypted: [PASS/FAIL]
‚úÖ Encrypted ‚Üí plain text: [PASS/FAIL]
‚úÖ Update re-encrypts: [PASS/FAIL]

Application Tests:
‚úÖ TypeScript read/decrypt: [PASS/FAIL]
‚úÖ TypeScript write/encrypt: [PASS/FAIL]
‚úÖ Hooks use views: [PASS/FAIL]

Document AI Tests:
‚úÖ Credentials encryption: [PASS/FAIL]
‚úÖ Credentials decryption: [PASS/FAIL]

Production Verification:
‚úÖ All keys encrypted: [PASS/FAIL]
‚úÖ Views accessible: [PASS/FAIL]
‚úÖ App functions normally: [PASS/FAIL]

Overall Status: [PASS/FAIL]
```

---

**Last Updated**: 2025-10-12  
**Status**: Ready for Testing  
**Next Step**: Run all tests and verify encryption is working correctly
