schema,name,definition
public,assign_default_user_role,"CREATE OR REPLACE FUNCTION public.assign_default_user_role()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Auto-assign role based on email
    IF NEW.email = 'superadmin@yachtexcel.com' THEN
        INSERT INTO public.user_roles (user_id, role, created_at, updated_at)
        VALUES (NEW.id, 'superadmin', NOW(), NOW())
        ON CONFLICT (user_id, role) DO NOTHING;
    ELSE
        INSERT INTO public.user_roles (user_id, role, created_at, updated_at)
        VALUES (NEW.id, 'user', NOW(), NOW())
        ON CONFLICT (user_id, role) DO NOTHING;
    END IF;
    
    RETURN NEW;
END;
$function$
"
public,ensure_user_role,"CREATE OR REPLACE FUNCTION public.ensure_user_role(user_id_param uuid, role_param text DEFAULT 'user'::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Insert role if it doesn't exist
    INSERT INTO public.user_roles (user_id, role, created_at, updated_at)
    VALUES (user_id_param, role_param, NOW(), NOW())
    ON CONFLICT (user_id, role) 
    DO UPDATE SET updated_at = NOW();
END;
$function$
"
public,handle_updated_at,"CREATE OR REPLACE FUNCTION public.handle_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
"
public,check_user_permission,"CREATE OR REPLACE FUNCTION public.check_user_permission(permission_name text)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
    user_email text;
    user_role text;
BEGIN
    -- Get current user email
    SELECT email INTO user_email 
    FROM auth.users 
    WHERE id = auth.uid();
    
    -- Check if superadmin
    IF user_email = 'superadmin@yachtexcel.com' THEN
        RETURN true;
    END IF;
    
    -- Get user role
    SELECT role INTO user_role
    FROM public.user_roles
    WHERE user_id = auth.uid()
    LIMIT 1;
    
    -- Basic permission checks
    CASE 
        WHEN permission_name = 'read' THEN
            RETURN true; -- All authenticated users can read
        WHEN permission_name = 'write' AND user_role IN ('admin', 'superadmin') THEN
            RETURN true;
        WHEN permission_name = 'delete' AND user_role = 'superadmin' THEN
            RETURN true;
        ELSE
            RETURN false;
    END CASE;
END;
$function$
"
public,sync_ai_provider_config,"CREATE OR REPLACE FUNCTION public.sync_ai_provider_config()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- If config is updated, copy to configuration
  IF NEW.config IS DISTINCT FROM OLD.config THEN
    NEW.configuration := NEW.config;
  END IF;
  
  -- If configuration is updated, copy to config  
  IF NEW.configuration IS DISTINCT FROM OLD.configuration THEN
    NEW.config := NEW.configuration;
  END IF;
  
  RETURN NEW;
END;
$function$
"
public,handle_new_user_signup,"CREATE OR REPLACE FUNCTION public.handle_new_user_signup()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Create user profile
    INSERT INTO public.user_profiles (user_id, display_name)
    VALUES (
        NEW.id,
        COALESCE(
            NEW.raw_user_meta_data->>'name',
            NEW.raw_user_meta_data->>'display_name', 
            split_part(NEW.email, '@', 1)
        )
    );
    
    -- Smart role assignment based on email domain and patterns
    IF NEW.email = 'superadmin@yachtexcel.com' THEN
        -- Designated superadmin gets superadmin role
        INSERT INTO public.user_roles (user_id, role, granted_by)
        VALUES (NEW.id, 'superadmin', NEW.id);
        
    ELSIF NEW.email LIKE '%@yachtexcel.com' THEN
        -- Company employees get admin role
        INSERT INTO public.user_roles (user_id, role, granted_by)
        VALUES (NEW.id, 'admin', NEW.id);
        
    ELSIF NEW.email LIKE '%admin%' OR NEW.email LIKE '%manager%' THEN
        -- Users with admin/manager in email get manager role
        INSERT INTO public.user_roles (user_id, role, granted_by)
        VALUES (NEW.id, 'manager', NEW.id);
        
    ELSE
        -- Regular users get user role
        INSERT INTO public.user_roles (user_id, role, granted_by)
        VALUES (NEW.id, 'user', NEW.id);
    END IF;
    
    RETURN NEW;
END;
$function$
"
public,get_user_roles,"CREATE OR REPLACE FUNCTION public.get_user_roles(_user_id uuid DEFAULT NULL::uuid)
 RETURNS TABLE(role text, department text, is_active boolean, expires_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    target_user_id UUID;
BEGIN
    target_user_id := COALESCE(_user_id, auth.uid());
    
    IF target_user_id IS NULL THEN
        RETURN;
    END IF;
    
    RETURN QUERY
    SELECT 
        ur.role, 
        ur.department, 
        ur.is_active,
        ur.expires_at
    FROM public.user_roles ur
    WHERE ur.user_id = target_user_id
    AND ur.is_active = true
    AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
    ORDER BY 
        CASE ur.role 
            WHEN 'superadmin' THEN 1 
            WHEN 'admin' THEN 2 
            WHEN 'manager' THEN 3 
            WHEN 'user' THEN 4 
            WHEN 'viewer' THEN 5 
            ELSE 6 
        END;
END;
$function$
"
public,user_has_permission,"CREATE OR REPLACE FUNCTION public.user_has_permission(_permission text, _resource text DEFAULT NULL::text, _action text DEFAULT NULL::text, _user_id uuid DEFAULT NULL::uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    target_user_id UUID;
    has_permission BOOLEAN DEFAULT FALSE;
    user_roles TEXT[];
BEGIN
    target_user_id := COALESCE(_user_id, auth.uid());
    
    IF target_user_id IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Get user's active roles
    SELECT ARRAY_AGG(role) INTO user_roles
    FROM public.user_roles ur
    WHERE ur.user_id = target_user_id
    AND ur.is_active = true
    AND (ur.expires_at IS NULL OR ur.expires_at > NOW());
    
    -- If no roles, return false
    IF user_roles IS NULL OR array_length(user_roles, 1) = 0 THEN
        RETURN FALSE;
    END IF;
    
    -- Check if user has superadmin role (grants all permissions)
    IF 'superadmin' = ANY(user_roles) THEN
        RETURN TRUE;
    END IF;
    
    -- Check specific permissions
    SELECT EXISTS (
        SELECT 1 
        FROM public.role_permissions rp
        WHERE rp.role = ANY(user_roles)
        AND rp.permission = _permission
        AND (_resource IS NULL OR rp.resource = _resource OR rp.resource = '*')
        AND (_action IS NULL OR rp.action = _action OR rp.action = '*')
    ) INTO has_permission;
    
    RETURN has_permission;
END;
$function$
"
public,assign_user_role,"CREATE OR REPLACE FUNCTION public.assign_user_role(_user_id uuid, _role text, _department text DEFAULT NULL::text, _granted_by uuid DEFAULT NULL::uuid, _expires_at timestamp with time zone DEFAULT NULL::timestamp with time zone)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    granter_id UUID;
BEGIN
    granter_id := COALESCE(_granted_by, auth.uid());
    
    -- Check if caller has permission to assign roles
    IF NOT public.user_has_permission('write', 'roles', 'assign_standard', granter_id) THEN
        RAISE EXCEPTION 'Insufficient permissions to assign roles';
    END IF;
    
    -- Prevent non-superadmins from assigning superadmin role
    IF _role = 'superadmin' AND NOT public.is_superadmin(granter_id) THEN
        RAISE EXCEPTION 'Only superadmins can assign superadmin role';
    END IF;
    
    INSERT INTO public.user_roles (
        user_id, role, department, granted_by, expires_at
    ) VALUES (
        _user_id, _role, _department, granter_id, _expires_at
    )
    ON CONFLICT (user_id, role, COALESCE(department, ''))
    DO UPDATE SET
        is_active = true,
        granted_by = granter_id,
        expires_at = _expires_at,
        updated_at = NOW();
    
    RETURN TRUE;
END;
$function$
"
public,is_superadmin,"CREATE OR REPLACE FUNCTION public.is_superadmin()
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN public.is_superadmin(auth.uid());
END;
$function$
"
public,is_superadmin,"CREATE OR REPLACE FUNCTION public.is_superadmin(_user_id uuid DEFAULT NULL::uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    target_user_id UUID;
    user_email TEXT;
BEGIN
    -- Use provided user_id or get current user
    target_user_id := COALESCE(_user_id, auth.uid());
    
    -- Return false if no user
    IF target_user_id IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Get user email from auth.users
    SELECT email INTO user_email 
    FROM auth.users 
    WHERE id = target_user_id;
    
    -- PRIORITY 1: Email-based superadmin detection (HIGHEST PRIORITY)
    IF user_email = 'superadmin@yachtexcel.com' THEN
        RETURN TRUE;
    END IF;
    
    -- PRIORITY 2: Check user_roles table for explicit superadmin role
    IF EXISTS (
        SELECT 1 
        FROM public.user_roles 
        WHERE user_id = target_user_id 
        AND role = 'superadmin'
        AND is_active = true
    ) THEN
        RETURN TRUE;
    END IF;
    
    -- Default: not superadmin
    RETURN FALSE;
END;
$function$
"
public,ensure_superadmin_role,"CREATE OR REPLACE FUNCTION public.ensure_superadmin_role()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- If user has superadmin email, ensure they have superadmin role
    IF NEW.email = 'superadmin@yachtexcel.com' THEN
        INSERT INTO public.user_roles (user_id, role, department, is_active, created_at)
        VALUES (NEW.id, 'superadmin', NULL, true, NOW())
        ON CONFLICT (user_id, role, COALESCE(department, ''))
        DO UPDATE SET 
            is_active = true,
            updated_at = NOW();
    END IF;
    
    RETURN NEW;
END;
$function$
"
public,current_user_is_superadmin,"CREATE OR REPLACE FUNCTION public.current_user_is_superadmin()
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN public.is_superadmin(auth.uid());
END;
$function$
"
public,is_superadmin_by_email,"CREATE OR REPLACE FUNCTION public.is_superadmin_by_email(user_id uuid DEFAULT NULL::uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1 FROM auth.users 
        WHERE id = COALESCE(user_id, auth.uid())
        AND email = 'superadmin@yachtexcel.com'
    );
$function$
"
